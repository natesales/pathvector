# Update time: {{ Timestamp "unix" }}

define ASN = {{ .ASN }};
router id {{ .RouterID }};

{{ if .Prefixes4 -}}
define LOCALv4 = [
{{ BirdSet .Prefixes4 }}
];
{{- end }}
{{ if or .Prefixes4 .Kernel.Statics4 }}
protocol static static4 {
  ipv4;
  {{- range $i, $prefix := .Prefixes4 }}
  route {{ $prefix }} reject;
  {{- end }}
  {{- range $prefix, $nexthop := MapDeref .Kernel.Statics4 }}
  route {{ $prefix }} via {{ $nexthop }};
  {{- end }}
}
{{- end }}

{{ if .Prefixes6 -}}
define LOCALv6 = [
{{ BirdSet .Prefixes6 }}
];
{{- end }}
{{ if or .Prefixes6 .Kernel.Statics6 }}
protocol static static6 {
  ipv6;
  {{- range $i, $prefix := .Prefixes6 }}
  route {{ $prefix }} reject;
  {{- end }}
  {{- range $prefix, $nexthop := .Kernel.Statics6 }}
  route {{ $prefix }} via {{ $nexthop }};
  {{- end }}
}
{{- end }}

{{ if .DefaultRoute -}}
protocol static default4 {
  ipv4;
  route 0.0.0.0/0 reject;
}

protocol static default6 {
  ipv6;
  route ::/0 reject;
}
{{- end }}

# ---- Parameters ----

timeformat base iso long;
timeformat log iso long;
timeformat protocol iso long;
timeformat route iso long;

log {{ if eq .LogFile "syslog" }}syslog{{ else }}"{{ .LogFile }}"{{ end }} all;

protocol device {};

protocol direct { ipv4; ipv6; }

protocol kernel {
  scan time {{ .Kernel.ScanTime }};
  {{ if .Kernel.Learn }}learn;{{ end }}
  {{ if .Kernel.Table }}kernel table {{ .Kernel.Table }};{{ end }}
  ipv4 {
    export filter {
      {{ if .Kernel.Export }}
      {{ if .Kernel.RejectConnected }}if source = RTS_DEVICE then reject;{{ end }}
      {{ $length := len .Kernel.SRDCommunities }}{{ if eq $length 0 }}
      {{- range $i, $rule := .Kernel.Accept4 }}
      if (proto = "{{ $rule }}") then accept;
      {{- end }}
      {{- range $i, $rule := .Kernel.Reject4 }}
      if (proto = "{{ $rule }}") then reject;
      {{- end }}
      {{ if .Source4 -}}
      if source = RTS_STATIC {{ if .Prefixes4 -}}&& proto != "static4"{{ end }} then {
        accept;
      } else if source = RTS_BGP then {
        krt_prefsrc = {{ .Source4 }};
        accept;
      }
      reject;
      {{ else }}
      accept;
      {{ end }}
      {{ else }}
      {{ $source4 := .Source4 }}
      {{ range $i, $community := StringSliceIter .Kernel.SRDStandardCommunities }}
      if (({{ $community }}) ~ bgp_community) then { {{ if $source4 }}krt_prefsrc = {{ $source4 }};{{ end }} accept; }
      {{ end }}
      {{ range $i, $community := StringSliceIter .Kernel.SRDLargeCommunities }}
      if (({{ $community }}) ~ bgp_large_community) then { {{ if $source4 }}krt_prefsrc = {{ $source4 }};{{ end }} accept; }
      {{ end }}
      reject;
      {{ end }}
      {{ else }}reject;{{ end }}
    };
  };
  {{ if .MergePaths }}merge paths;{{ end }}
}

protocol kernel {
  scan time {{ .Kernel.ScanTime }};
  {{ if .Kernel.Learn }}learn;{{ end }}
  {{ if .Kernel.Table }}kernel table {{ .Kernel.Table }};{{ end }}
  ipv6 {
    export filter {
      {{ if .Kernel.Export }}
      {{ if .Kernel.RejectConnected }}if source = RTS_DEVICE then reject;{{ end }}
      {{ $length := len .Kernel.SRDCommunities }}{{ if eq $length 0 }}
      {{- range $i, $rule := .Kernel.Accept6 }}
      if (proto = "{{ $rule }}") then accept;
      {{- end }}
      {{- range $i, $rule := .Kernel.Reject6 }}
      if (proto = "{{ $rule }}") then reject;
      {{- end }}
      {{ if .Source6 -}}
      if source = RTS_STATIC {{ if .Prefixes6 -}}&& proto != "static6"{{ end }} then {
        accept;
      } else if source = RTS_BGP then {
        krt_prefsrc = {{ .Source6 }};
        accept;
      } else {
        reject;
      }
      {{ else }}
      accept;
      {{ end }}
      {{ else }}
      {{ $source6 := .Source6 }}
      {{ range $i, $community := StringSliceIter .Kernel.SRDStandardCommunities }}
      if (({{ $community }}) ~ bgp_community) then { {{ if $source6 }}krt_prefsrc = {{ $source6 }};{{ end }} accept; }
      {{ end }}
      {{ range $i, $community := StringSliceIter .Kernel.SRDLargeCommunities }}
      if (({{ $community }}) ~ bgp_large_community) then { {{ if $source6 }}krt_prefsrc = {{ $source6 }};{{ end }} accept; }
      {{ end }}
      reject;
      {{ end }}
      {{ else }}reject;{{ end }}
    };
  };
  {{ if .MergePaths }}merge paths;{{ end }}
}

# --- Blackholing ---

protocol static null4 {
  ipv4;
  route 192.0.2.1/32 blackhole;
}

protocol static null6 {
  ipv6;
  route 100::1/128 blackhole;
}

function set_blackhole() {
  if (net.type = NET_IP4) then {
    bgp_next_hop = 192.0.2.1;
    print "Added null route for ", net;
  }
  if (net.type = NET_IP6) then {
    bgp_next_hop = 100::1;
    print "Added null route for ", net;
  }
}

function process_blackholes() {
  if (((ASN,1,666) ~ bgp_large_community) && ((net.type = NET_IP4 && net.len = 32) || (net.type = NET_IP6 && net.len = 128))) then {
    set_blackhole();
  }
}

# ---- RPKI ----

{{ if .RPKIEnable }}
roa4 table rpki4;
roa6 table rpki6;

protocol rpki {
  roa4 { table rpki4; };
  roa6 { table rpki6; };

  transport tcp;
  remote "{{ .RTRServerHost }}" port {{ .RTRServerPort }};

  retry keep 90;
  refresh keep 900;
  expire keep 172800;
}
{{ end }}

# ---- Filter Lists ----
# Prefix and ASN lists are adapted from https://github.com/neptune-networks/peering/blob/master/templates/bird.conf.erb and https://github.com/NLNOG/bgpfilterguide, check out those repos too!

define BOGONS_v4 = [
{{ BirdSet .Bogons4 }}
];

define BOGONS_v6 = [
{{ BirdSet .Bogons6 }}
];

define BOGON_ASNS = [
{{ BirdSet .BogonASNs }}
];

# Blocklist

{{ if gt (len .BlocklistASNs) 0 }}
define BLOCKLIST_ASNS = [
{{ BirdASSet .BlocklistASNs }}
];
{{ end }}

{{ if gt (len .BlocklistPrefixes) 0 }}
define BLOCKLIST_PREFIXES = [
{{ BirdSet .BlocklistPrefixes }}
];
{{ end }}

# Helper Functions

function _reject(string reason) {
  reject "REJECTED [", reason, "] pfx ", net, " session ", proto, " path ", bgp_path, " pathlen ", bgp_path.len, " origin ", bgp_path.last;
}

function reject_blocklist() {
  {{ if gt (len .BlocklistPrefixes) 0 }}if (net ~ BLOCKLIST_PREFIXES) then { _reject("prefix in blocklist"); }{{ end }}
  {{ if gt (len .BlocklistASNs) 0 }}if (bgp_path ~ BLOCKLIST_ASNS) then { _reject("ASN in blocklist"); }{{ end }}
}

# Filtering Functions

function reject_transit_paths() {
  if (bgp_path ~ {{ ASSet .TransitASNs }}) then _reject("transit path");
}

function honor_graceful_shutdown() {
  if (65535, 0) ~ bgp_community then bgp_local_pref = 0;
}

function reject_local() {
  {{ if .Prefixes4 -}}
  if (net ~ LOCALv4) then _reject("own prefix");
  {{- end }}
  {{ if .Prefixes6 -}}
  if (net ~ LOCALv6) then _reject("own prefix");
  {{- end }}
}

function reject_bogon_asns() {
  if (bgp_path ~ BOGON_ASNS) then {
    {{ if .BlackholeBogonASNs }}
    set_blackhole();
    accept;
    {{ end }}
    _reject("bogon ASN in path");
  }
}

function reject_long_as_paths() {
  if (bgp_path.len > 100) then _reject("long AS path");
}

function reject_rpki_invalid() {
  {{ if .RPKIEnable }}
  if (net.type = NET_IP4) then {
    if (roa_check(rpki4, net, bgp_path.last_nonaggregated) = ROA_INVALID) then _reject("RPKI invalid");
  }

  if (net.type = NET_IP6) then {
    if (roa_check(rpki6, net, bgp_path.last_nonaggregated) = ROA_INVALID) then _reject("RPKI invalid");
  }
  {{ end }}
}

function force_rpki_strict() {
  {{ if .RPKIEnable }}
  if (net.type = NET_IP4) then {
    if (roa_check(rpki4, net, bgp_path.last_nonaggregated) != ROA_VALID) then _reject("RPKI != ROA_VALID");
  }

  if (net.type = NET_IP6) then {
    if (roa_check(rpki6, net, bgp_path.last_nonaggregated) != ROA_VALID) then _reject("RPKI != ROA_VALID");
  }
  {{ end }}
}

function reject_out_of_bounds_routes() {
  {{ if .AcceptDefault -}}if (net.len = 0) then return 0;{{ end }}

  if (net.type = NET_IP4) then {
    if (net.len > 24 || net.len < 8) then _reject("out of bounds (24 > len > 8)");
  }

  if (net.type = NET_IP6) then {
    if (net.len > 48 || net.len < 12) then _reject("out of bounds (48 > len > 12)");
  }
}

function reject_bogon_routes() {
  if (net.type = NET_IP4) then {
    if (net ~ BOGONS_v4) then _reject("bogon route");
  }

  if (net.type = NET_IP6) then {
    if (net ~ BOGONS_v6) then _reject("bogon route");
  }
}

{{ if .QueryNVRS }}
function reject_never_via_route_servers() {
  if (bgp_path ~ [{{ range $index, $element := .NVRSASNs}}{{if $index}},{{end}}{{$element}}{{end}}]) then _reject("NVRS route");
}
{{ end }}

function enforce_first_as(int peer_asn) {
  if (bgp_path.first != peer_asn) then _reject("invalid first AS");
}

function enforce_peer_nexthop(ip addr) {
  if (bgp_next_hop != addr) then _reject("nexthop doesn't match neighbor address");
}

# Processing Functions

function remove_private_asns() {
  bgp_path.delete([64512..65534, 4200000000..4294967294]);
}

function accept_local() {
  {{ range $i, $community := StringSliceIter .OriginStandardCommunities }}
  if (({{ $community }}) ~ bgp_community) then accept;
  {{ end }}
  {{ range $i, $community := StringSliceIter .OriginLargeCommunities }}
  if (({{ $community }}) ~ bgp_large_community) then accept;
  {{ end }}

  {{ if .Prefixes4 -}}
  if (net ~ LOCALv4) then {
    {{ range $i, $community := StringSliceIter .LocalStandardCommunities }}
    bgp_community.add(({{ $community }}));
    {{ end }}
    {{ range $i, $community := StringSliceIter .LocalLargeCommunities }}
    bgp_large_community.add(({{ $community }}));
    {{ end }}
    accept;
  }
  {{- end }}

  {{ if .Prefixes6 -}}
  if (net ~ LOCALv6) then {
    {{ range $i, $community := StringSliceIter .LocalStandardCommunities }}
    bgp_community.add(({{ $community }}));
    {{ end }}
    {{ range $i, $community := StringSliceIter .LocalLargeCommunities }}
    bgp_large_community.add(({{ $community }}));
    {{ end }}
    accept;
  }
  {{- end }}
}

# ---- BFD ----
{{ range $i, $instance := .BFDInstances }}
protocol bfd {{ StrDeref $instance.ProtocolName }} {
  neighbor {{ StrDeref $instance.Neighbor }};
  interface "{{ StrDeref $instance.Interface }}" {
    interval {{ UintDeref $instance.Interval }} ms;
    multiplier {{ UintDeref $instance.Multiplier }};
  };
}
{{ end }}

# ---- MRT ----
{{ range $i, $instance := .MRTInstances }}
protocol mrt {{ StrDeref $instance.ProtocolName }} {
  filename "{{ StrDeref $instance.File }}";
  period "{{ UintDeref $instance.Interval }}";
  {{ if $instance.Table }}table "{{ StrDeref $instance.Table }}";{{ end }}
}
{{ end }}
# ---- Custom global config ----

{{ .GlobalConfig }}

include "manual*.conf";
include "AS*.conf";
